#!/usr/bin/env python3
"""
Test malware functionality to verify it performs malicious actions (Task point 5).
Tests: file encryption, ransom note creation, registry persistence.
"""

import os
import sys
import subprocess
import shutil
import tempfile
import json
from pathlib import Path
from typing import Dict, List, Tuple

class MalwareTester:
    """Test malware executables for malicious functionality."""
    
    def __init__(self, malware_dir: Path):
        self.malware_dir = malware_dir
        self.results = []
    
    def create_test_environment(self) -> Path:
        """Create a temporary test directory with sample files."""
        test_dir = Path(tempfile.mkdtemp(prefix="malware_test_"))
        
        # Create test Documents folder structure
        docs_dir = test_dir / "Documents"
        docs_dir.mkdir()
        
        # Create test .txt files
        test_files = [
            "important_document.txt",
            "secret_data.txt",
            "personal_info.txt"
        ]
        
        for filename in test_files:
            test_file = docs_dir / filename
            test_file.write_text(f"This is test content for {filename}\n" * 10)
        
        return test_dir
    
    def check_file_encryption(self, test_dir: Path) -> Dict:
        """Check if files were encrypted."""
        docs_dir = test_dir / "Documents"
        results = {
            'files_encrypted': 0,
            'files_renamed': 0,
            'original_files': [],
            'encrypted_files': []
        }
        
        if not docs_dir.exists():
            return results
        
        # Check for .encrypted files
        encrypted_files = list(docs_dir.glob("*.encrypted"))
        results['encrypted_files'] = [f.name for f in encrypted_files]
        results['files_renamed'] = len(encrypted_files)
        
        # Check if original .txt files still exist (they shouldn't)
        original_files = list(docs_dir.glob("*.txt"))
        # Filter out ransom note
        original_files = [f for f in original_files if f.name != "README_ENCRYPTED.txt"]
        results['original_files'] = [f.name for f in original_files]
        
        # Files are encrypted if they were renamed to .encrypted
        results['files_encrypted'] = len(encrypted_files)
        
        # Also check if file content changed (XOR encryption would change bytes)
        for enc_file in encrypted_files:
            try:
                content = enc_file.read_bytes()
                # Check if content is not plain text (encrypted)
                # Encrypted files will have non-printable characters
                if any(b < 32 and b not in [9, 10, 13] for b in content[:100]):
                    results['files_encrypted'] = max(results['files_encrypted'], 1)
            except:
                pass
        
        return results
    
    def check_ransom_note(self, test_dir: Path) -> Dict:
        """Check if ransom note was created."""
        docs_dir = test_dir / "Documents"
        ransom_note = docs_dir / "README_ENCRYPTED.txt"
        
        result = {
            'exists': False,
            'content': None,
            'size': 0
        }
        
        if ransom_note.exists():
            result['exists'] = True
            result['content'] = ransom_note.read_text()
            result['size'] = ransom_note.stat().st_size
        
        return result
    
    def check_registry_persistence(self, exe_path: Path) -> Dict:
        """Check if registry persistence was attempted."""
        # Note: On Linux/Wine, registry may not work the same way
        # This is a placeholder - actual registry checking would need Windows
        result = {
            'persistence_attempted': True,  # We know the code tries to set it
            'registry_key': 'HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run',
            'note': 'Full registry verification requires Windows environment'
        }
        return result
    
    def test_malware(self, exe_path: Path, test_dir: Path) -> Dict:
        """Test a single malware executable."""
        print(f"\n[*] Testing: {exe_path.name}")
        
        # Copy malware to test directory
        test_exe = test_dir / exe_path.name
        shutil.copy2(exe_path, test_exe)
        test_exe.chmod(0o755)
        
        # Set up environment variables to simulate Documents folder
        env = os.environ.copy()
        env['USERPROFILE'] = str(test_dir)
        env['HOME'] = str(test_dir)
        
        # Create Documents folder path
        docs_dir = test_dir / "Documents"
        docs_dir.mkdir(exist_ok=True)
        
        # Create test files before running malware
        test_files_before = list(docs_dir.glob("*.txt"))
        
        result = {
            'file': exe_path.name,
            'executed': False,
            'exit_code': None,
            'file_encryption': {},
            'ransom_note': {},
            'registry_persistence': {},
            'error': None
        }
        
        try:
            # Try to run with Wine (if available) or wine64
            wine_cmd = None
            for cmd in ['wine64', 'wine']:
                try:
                    subprocess.run([cmd, '--version'], 
                                 capture_output=True, check=True, timeout=5)
                    wine_cmd = cmd
                    break
                except (FileNotFoundError, subprocess.TimeoutExpired):
                    continue
            
            if not wine_cmd:
                result['error'] = "Wine not found - cannot execute Windows PE files on Linux"
                result['note'] = "For full testing, use Windows VM or Wine"
                return result
            
            # Run the malware
            print(f"  [*] Executing with {wine_cmd}...")
            process = subprocess.run(
                [wine_cmd, str(test_exe)],
                cwd=str(test_dir),
                env=env,
                capture_output=True,
                timeout=30
            )
            
            result['executed'] = True
            result['exit_code'] = process.returncode
            result['stdout'] = process.stdout.decode('utf-8', errors='ignore')[:500]
            result['stderr'] = process.stderr.decode('utf-8', errors='ignore')[:500]
            
            # Wait a moment for file operations to complete
            import time
            time.sleep(1)
            
            # Check results
            result['file_encryption'] = self.check_file_encryption(test_dir)
            result['ransom_note'] = self.check_ransom_note(test_dir)
            result['registry_persistence'] = self.check_registry_persistence(exe_path)
            
        except subprocess.TimeoutExpired:
            result['error'] = "Execution timed out"
        except Exception as e:
            result['error'] = str(e)
        
        return result
    
    def run_tests(self) -> List[Dict]:
        """Run tests on all malware executables."""
        exe_files = sorted(self.malware_dir.glob("*.exe"))
        
        if not exe_files:
            print("[!] No .exe files found")
            return []
        
        print(f"[*] Found {len(exe_files)} malware executables to test")
        print("[*] Creating test environment...")
        
        results = []
        
        for exe_file in exe_files:
            test_dir = self.create_test_environment()
            try:
                result = self.test_malware(exe_file, test_dir)
                results.append(result)
                
                # Print results
                print(f"\n  Results for {exe_file.name}:")
                if result.get('error'):
                    print(f"    [!] Error: {result['error']}")
                else:
                    print(f"    [*] Executed: {result['executed']}")
                    print(f"    [*] Exit code: {result['exit_code']}")
                    
                    enc = result.get('file_encryption', {})
                    print(f"    [*] Files encrypted: {enc.get('files_encrypted', 0)}")
                    print(f"    [*] Files renamed: {enc.get('files_renamed', 0)}")
                    
                    ransom = result.get('ransom_note', {})
                    print(f"    [*] Ransom note created: {ransom.get('exists', False)}")
                    
                    if ransom.get('exists'):
                        print(f"    [*] Ransom note size: {ransom.get('size', 0)} bytes")
                
            finally:
                # Cleanup
                try:
                    shutil.rmtree(test_dir)
                except:
                    pass
        
        return results
    
    def print_summary(self, results: List[Dict]):
        """Print test summary."""
        print(f"\n{'='*60}")
        print("TEST SUMMARY")
        print(f"{'='*60}")
        
        total = len(results)
        executed = sum(1 for r in results if r.get('executed'))
        encrypted = sum(1 for r in results if r.get('file_encryption', {}).get('files_encrypted', 0) > 0)
        ransom_notes = sum(1 for r in results if r.get('ransom_note', {}).get('exists', False))
        
        print(f"Total variants tested: {total}")
        print(f"Successfully executed: {executed}")
        print(f"Encrypted files: {encrypted}")
        print(f"Created ransom notes: {ransom_notes}")
        
        print(f"\n{'='*60}")
        print("DETAILED RESULTS")
        print(f"{'='*60}")
        
        for result in results:
            print(f"\n{result['file']}:")
            print(f"  Executed: {result.get('executed', False)}")
            
            if result.get('file_encryption'):
                enc = result['file_encryption']
                print(f"  Files encrypted: {enc.get('files_encrypted', 0)}")
                if enc.get('encrypted_files'):
                    print(f"  Encrypted files: {', '.join(enc['encrypted_files'][:5])}")
            
            if result.get('ransom_note'):
                ransom = result['ransom_note']
                print(f"  Ransom note: {ransom.get('exists', False)}")
                if ransom.get('exists') and ransom.get('content'):
                    preview = ransom['content'][:100].replace('\n', ' ')
                    print(f"  Note preview: {preview}...")
            
            if result.get('error'):
                print(f"  Error: {result['error']}")


def main():
    """Main test execution."""
    malware_dir = Path("generated_malware")
    
    if not malware_dir.exists():
        print(f"[!] Error: {malware_dir} directory not found")
        sys.exit(1)
    
    tester = MalwareTester(malware_dir)
    results = tester.run_tests()
    tester.print_summary(results)
    
    # Save results to JSON
    output_file = Path("malware_test_results.json")
    with open(output_file, 'w') as f:
        json.dump(results, f, indent=2)
    print(f"\n[*] Results saved to: {output_file}")
    
    # Determine if tests passed
    malicious_count = sum(1 for r in results 
                         if r.get('file_encryption', {}).get('files_encrypted', 0) > 0 
                         or r.get('ransom_note', {}).get('exists', False))
    
    if malicious_count > 0:
        print(f"\n[âœ“] {malicious_count} variants demonstrated malicious behavior")
        return 0
    else:
        print(f"\n[!] No variants demonstrated malicious behavior")
        print("[*] Note: Full testing may require Windows environment")
        return 1


if __name__ == '__main__':
    sys.exit(main())

